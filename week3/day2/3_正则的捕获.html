<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
    /* 
        匹配  test
        捕获  exec  从字符串中获取 满足 正则的部分 字符
    */
   var reg = /\d+/
   var str = '珠峰2019zf2020';
   var res = reg.exec(str)
   console.log(res)

   //exec 捕获的结果 第一项是大正则捕获到的内容， 第二项及以后是小分组捕获的内容
   //第二项 就是第一个小分组； 第三项就是 第二个小分组。。。
   //若字符串中没有任何符合正则的字符；则获取到的结果就是一个null；

   var reg = /([a-z]+)(\d+)/
   var str = '珠峰2019zf,2020';
   var res = reg.exec(str)
   console.log(res)

   //正则的贪婪性：一次性会把所有满足正则的字符都捕获到
   //解决正则的贪婪性 ？
   var reg = /\d+?/
   var str = 'hello珠峰2019zf2020';
   console.log(reg.exec(str))

   //捕获的懒惰性；只捕获一次不再捕获其他符合的
   //解决正则的懒惰性  通过添加全局修饰符 g解决；加上g之后 每一次捕获时都会更新 lastIndex这个属性
   //lastIndex属性是控制的下一次开始匹配的开始索引；
   //test和exec方法都会更新lastIndex属性；
  var reg = /\d+/g;
   var str = 'hello珠峰2019zf2020';
   reg.test(str)
   console.log(reg.exec(str));
   //当换行的时候加了m也会匹配到
   var reg = /^a/m
   var str = `bcd\nabd`
   console.log(reg.test(str))
</script>