<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
    /* 
        正则 匹配 捕获
        var reg = /^\d$/
        var reg = /\d/
        方法都在正则类的原型上
        ()小分组 捕获   exec
        提升优先级 匹配 test
        global     
        ignoreCase
        mutiline

        捕获的懒惰性  g   
        捕获的贪婪性  在量词元字符后边添加一个？
     */
     var reg = /\d+/
     var str = '珠峰2019珠峰2020';
     //每个正则都会有一个lastIndex的属性；没有g则每次的lastIndex都是0；有g之后下一次的lastIndex是上一次捕获结束的位置
     //若正则不匹配字符串 则获取到的就是null
     reg.exec(str);
     reg.exec(str);
     reg.exec(str)
     //exec 的返回值是个数组 数组中第一项是大正则捕获的内容 第二项及以后分别对应 各个小分组对应的内容
     var reg = /([a-z]+)(\d+)/;
     var str = '珠峰2019珠峰zf2020';
     reg.exec(str);//['zf2020','zf','2020']
     RegExp.prototype.execAll = function(str){
         let _this = this;
         if(!this.global){
            _this =eval(_this + 'g') 
         }
        let res = _this.exec(str);
        let arr = [];
        while(res){
            arr.push(res);
            res = _this.exec(str);
        }
        return arr
     }
    
     var reg = /(\d)+/;//小分组捕获的是最后的一个
     var str = '珠峰2019珠峰zf2020';
     console.log(reg.execAll(str))
     
</script>