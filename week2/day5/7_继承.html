<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
    //类的继承 封装（高内聚 低耦合） 多态（函数的多种形态，多个参数，arguments）

    function Person(name,age){
        //call 继承；这种继承方式只能继承私有属性；
        Animal.call(this,10000);//把Animal中的this 换成当前的实例；把10000传给了Animal
        this.name = name;
        this.age = age;
    }
    //Person.prototype =  Animal.prototype;//让Person的原型指向了 Animal的原型
    //继承方式 第一种方式
   /*  Person.prototype = new Animal();//让Person的原型指向了 Animal的某个实例
    //这种继承方式的缺点是Person类继承了Animal类的所有属性 */
    //继承 组合式继承
    Person.prototype = Object.create(Animal.prototype);//create创造了一个空对象 空对象的__proto__指向了 Animal的prototype
    Person.prototype.eat = function(){
        console.log('吃')
    }
    
    function Animal(iq){
        this.iq = iq;
    }
    Animal.prototype.move = function(){
        console.log('能动')
    }
    Animal.prototype.sleep = function(){
        console.log('休息')
    }
    var p1 = new Person('小明',100);
    p1.move()

//class继承
class Parent{
    constructor(){
        this.name = 'parent';
        this.age = 100
    }
    say(){
        console.log('hello parent')
    }
    static qqq = 121
}
class Child extends Parent{
    constructor(){
        super()//写了 extents 和 constructor； 则必写 super();super 其实就是 Parent的constructor;
        this.money = 100;
    }
    play(){
        console.log('child play')
    }
}
var xm = new Child();
console.log(xm);
</script>