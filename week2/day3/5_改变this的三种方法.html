<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
    //call 是用来改变函数内部的this指向的；
    function fn(){
        /* 
        三种把类数组转换成数组的方式
        console.log([].slice.call(arguments,0))//[1].slice(0)
        console.log([...arguments])
        console.log(Array.from(arguments))
         */
        
        console.log(arguments)
        console.log(this)
    }
    var obj = {
        a:12,
        b:13,
        f:fn
    }
    // fn(1,2,3)

    //fn.call(obj,5,5,5)
    //call 可以让函数执行，并且可以改变函数执行时，内部的this指向，
    //     this指向了 call的第一个实参，call后边的所有的参数，都被作为实参传给了 前边的函数，
    Object.prototype.toString.call('')

    //call 方法是在Function的原型上

    //自己实现一个 myCall的方法 用法等同于 call;
    Function.prototype.myCall=function myCall(context,...arg){//...剩余运算符
        //this---> fn
        //this(...arg)//...扩展运算符
        //让fn（this)执行 并且让函数中的this是context;
        //context.qqq() qqq执行时里边的this 是context
        /* context.qqq = this;//context.qqq--->fn
        context.qqq(...arg)//让fn执行了
        delete context.qqq//删除增加的属性 */
        context = context || window
        let a = Symbol();//产生一个唯一的不会重复的值 
        context[a] = this;
        let res = context[a](...arg);
        delete context[a];
        return res;
    }
    fn.myCall(obj,1,2,3)//让fn执行；fn中的this 指向obj 把 6，6，6 传给fn
</script>