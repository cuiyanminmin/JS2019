<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
    /* 
        类          实例
        人类        奥巴马
        Array       []
        Object      {}    基类
        Function    f
     */
     //自定义类有两种方式一种是function 一种是class
     //function 声明（添加到原型上的方法是手动添加的）
     function Person(){
         this.name=123;
         this.age=234;
     }
     Person.prototype.eat=function(){}
     Person.prototype.play=function(){}
     var p1=new Person();
     //new 执行比普通函数执行 多了一个开辟堆内存，把this指向这个堆内存 的动作； 默认返回this

     //class自定义类（写的公用方法是内置放到原型上的）
     class Man{
         constructor(){
             this.name=666;
             this.age=555;
         }
         eat(){}
         play(){}
     }

     //原型链 属性的查找机制；当我们调用一个属性的时候，先在自己身上查找，没有的话 会通过__proto__
     //       向所属类的原型查找，没有的话再通过原型的__proto__向上级查找，直到找到基类，如果还是没有结果就是undefined
     /* 
        每一个函数（类） 都有一个天生自带的属性prototype；指向自己的原型对象；
        每一个对象（实例）都有一个天生自带的__proto__；指向所属类的原型对象；
        每一个默认的原型对象上都有一个constructor属性；指向对应的构造函数本身
      */

      //hasOwnProperty 在基类的原型上
      //constructor 判断数据类型的原理； 原型重构(Person.prototype={constructor:Person})
      // xxx instanceof  zzz;从xxx到基类的原型链上 是否存在zzz的身影；不适合基本数据类型；
      
</script>