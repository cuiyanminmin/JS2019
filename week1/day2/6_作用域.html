<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
    //typeScript
    //作用域 就是代码能够起作用（能影响）的区域
    //全局作用域 和 私有作用域
    //作用域 就是一块栈内存
    //堆内存是用来存储引用数据类型的
    //栈内存是用来存储值类型的 还有就是提供代码运行环境的
    /* 
        全局作用域：页面一打开就会形成一个全局作用域，一个页面只有一个全局作用域
        私有作用域：在函数执行的时候，会形成一个私有的作用域
        块级作用域：指的是 判断句 循环句 的大括号包起来的部分 es6新增的 只有let和const声明的变量能识别块级作用域，对于var来说不存在块级作用域这一说

        全局作用域中声明的变量我们称为全局变量
        私有作用域中声明的变量我们称为私有变量；形参也是私有变量；

        上级作用域 
            函数执行时形成的那个私有作用域，一般都会存在一个上级作用域，私有作用域的上级作用域是谁，跟这个函数在哪里执行没有关系，只跟函数在那个作用域定义的有关系

        私有作用域中的变量 ，有可能不是该私有作用域的私有变量，这时该变量对应的值就需要去上级作用域查找，若仍不是上级作用域的私有变量，则接着向上级查找，直到找到window（全局）的位置，若仍没有则就报错；
        上述查找变量的机制 我们称为 作用域链

        函数执行时 先有形参赋值 再有变量提升；
    */
    /*  let a = 13;

     //    f();
     function f2() {
         var b = 100;
         function f() {
             console.log(b)
             a = 100;
         }
         // f()
         return f
     }
     var f3=f2();
     f3() */
    // var a=10;
    // if(1<2){
    //     var a=12;
    //     console.log(a)
    // }
    // console.log(a)

    // var b=10;
    // if(1<2){
    //     let b=12;
    //     console.log(b)
    // }
    // console.log(b)
    var a = 12;

    function f() {
        console.log(a); //let 和 const 它在声明之前绝对不能调用（报错）
        let a = 100;
    }
    f();
    console.log(a)


    f = function () {
        return true
    };
    g = function () {
        return false
    };
    (function () {
        console.log(g);
        if (g() && [] == ![]) {
            f = function f() {
                return false
            };
        }

        function g() {
            return true
        };
    })();
    alert(f());
    alert(g())
</script>